generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Settings {
  id       Int  @id @default(autoincrement())
  settings Json
}

model Client {
  id                 Int       @id @default(autoincrement())
  applicationName    String
  applicationUrl     String
  allowedCorsOrigins String[]
  updatedAt          DateTime
  createdAt          DateTime
  deletedAt          DateTime?
}

model User {
  id                                  Int                             @id @default(autoincrement())
  email                               String                          @unique
  name                                String?
  password                            String                          @default("")
  refresh                             String?
  artists                             Artist[]
  createdAt                           DateTime                        @default(now())
  updatedAt                           DateTime                        @default(now()) @updatedAt
  deletedAt                           DateTime?
  isAdmin                             Boolean                         @default(false)
  artistUserSubscriptions             ArtistUserSubscription[]
  currency                            String?
  userTrackGroupPurchases             UserTrackGroupPurchase[]
  emailConfirmationToken              String?                         @default(uuid()) @db.Uuid
  emailConfirmationExpiration         DateTime?                       @default(dbgenerated("(NOW() + '00:20:00'::interval)"))
  passwordResetConfirmationToken      String?
  passwordResetConfirmationExpiration DateTime?
  stripeAccountId                     String?
  receiveMailingList                  Boolean                         @default(false)
  wishlist                            UserTrackGroupWishlist[]
  plays                               TrackPlay[]
  downloadCodes                       TrackGroupDownloadCodes[]
  userArtistNotificationSettings      UserArtistNotificationSetting[]
  receivingNotifications              Notification[]                  @relation("receivingUser")
  relatedNotifications                Notification[]                  @relation("relatedUser")
}

model UserArtistNotificationSetting {
  userId       Int
  user         User             @relation(fields: [userId], references: [id])
  notification NotificationType
  isEnabled    Boolean          @default(true)
  artistId     Int
  artist       Artist           @relation(fields: [artistId], references: [id])

  @@unique([userId, notification])
}

model Notification {
  id               String                  @id @default(uuid())
  isRead           Boolean                 @default(false)
  userId           Int
  user             User                    @relation(fields: [userId], references: [id], name: "receivingUser")
  notificationType NotificationType
  createdAt        DateTime                @default(now())
  content          String?
  trackGroupId     Int?
  trackGroup       TrackGroup?             @relation(fields: [trackGroupId], references: [id])
  subscriptionId   Int?
  subscription     ArtistUserSubscription? @relation(fields: [subscriptionId], references: [id])
  postId           Int?
  post             Post?                   @relation(fields: [postId], references: [id])
  artistId         Int?
  artist           Artist?                 @relation(fields: [artistId], references: [id])
  relatedUserId    Int?
  relatedUser      User?                   @relation(fields: [relatedUserId], references: [id], name: "relatedUser")
}

enum NotificationType {
  NEW_ARTIST_MONTHLY_SUBSCRIPTION
  NEW_ARTIST_POST
  NEW_ARTIST_ALBUM
  USER_FOLLOWED_YOU
  USER_BOUGHT_YOUR_ALBUM
  USER_SUBSCRIBED_TO_YOU
}

model Post {
  id                        Int                     @id @default(autoincrement())
  createdAt                 DateTime                @default(now())
  updatedAt                 DateTime                @default(now()) @updatedAt
  deletedAt                 DateTime?
  title                     String
  content                   String?
  publishedAt               DateTime                @default(now())
  viewCount                 Int                     @default(0)
  artist                    Artist?                 @relation(fields: [artistId], references: [id])
  artistId                  Int?
  isPublic                  Boolean                 @default(false)
  minimumSubscriptionTierId Int?
  minimumSubscriptionTier   ArtistSubscriptionTier? @relation(fields: [minimumSubscriptionTierId], references: [id])
  hasAnnounceEmailBeenSent  Boolean                 @default(false)
  postSubscriptionTiers     PostSubscriptionTier[]
  notifications             Notification[]
  shouldSendEmail           Boolean                 @default(true)
}

model PostSubscriptionTier {
  postId                   Int
  post                     Post                    @relation(fields: [postId], references: [id])
  artistSubscriptionTierId Int
  artistSubscriptionTier   ArtistSubscriptionTier? @relation(fields: [artistSubscriptionTierId], references: [id])

  @@unique([postId, artistSubscriptionTierId])
}

model Artist {
  id                                 Int                                  @id @default(autoincrement())
  name                               String
  bio                                String?
  user                               User                                 @relation(fields: [userId], references: [id])
  userId                             Int
  posts                              Post[]
  trackGroups                        TrackGroup[]
  enabled                            Boolean                              @default(true)
  createdAt                          DateTime                             @default(now())
  updatedAt                          DateTime                             @default(now()) @updatedAt
  deletedAt                          DateTime?
  subscriptionTiers                  ArtistSubscriptionTier[]
  banner                             ArtistBanner?
  avatar                             ArtistAvatar?
  urlSlug                            String                               @unique
  properties                         Json?
  trackArtists                       TrackArtist[]
  links                              String[]
  location                           String?
  artistUserSubscriptionConfirmation ArtistUserSubscriptionConfirmation[]
  userArtistNotificationSettings     UserArtistNotificationSetting[]
  notifications                      Notification[]
}

model ArtistAvatar {
  id               String    @id @default(uuid()) @db.Uuid
  url              String[]
  artist           Artist    @relation(fields: [artistId], references: [id])
  artistId         Int       @unique
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  deletedAt        DateTime?
  originalFilename String?
}

model ArtistBanner {
  id               String    @id @default(uuid()) @db.Uuid
  url              String[]
  artist           Artist    @relation(fields: [artistId], references: [id])
  artistId         Int       @unique
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  deletedAt        DateTime?
  originalFilename String?
}

model ArtistSubscriptionTier {
  id                    Int                      @id @default(autoincrement())
  name                  String
  description           String                   @default("")
  artistId              Int
  artist                Artist                   @relation(fields: [artistId], references: [id])
  minAmount             Int? // in cents
  allowVariable         Boolean?
  maxAmount             Int? // in cents
  defaultAmount         Int? // in cents
  currency              String                   @default("USD")
  userSubscriptions     ArtistUserSubscription[]
  stripeProductKey      String?
  createdAt             DateTime                 @default(now())
  updatedAt             DateTime                 @default(now()) @updatedAt
  deletedAt             DateTime?
  minimumTierForPost    Post[]
  postSubscriptionTiers PostSubscriptionTier[]
  isDefaultTier         Boolean                  @default(false)
  platformPercent       Int?                     @default(7)
  autoPurchaseAlbums    Boolean                  @default(false)
}

model ArtistUserSubscription {
  id                       Int                    @id @default(autoincrement())
  artistSubscriptionTierId Int
  artistSubscriptionTier   ArtistSubscriptionTier @relation(fields: [artistSubscriptionTierId], references: [id])
  userId                   Int
  user                     User                   @relation(fields: [userId], references: [id])
  amount                   Int // In cents
  currency                 String                 @default("USD")
  stripeSubscriptionKey    String?
  createdAt                DateTime               @default(now())
  updatedAt                DateTime               @default(now()) @updatedAt
  deletedAt                DateTime?
  notifications            Notification[]

  @@unique([userId, artistSubscriptionTierId])
}

model ArtistUserSubscriptionConfirmation {
  id              String    @id @default(uuid()) @db.Uuid
  email           String
  artistId        Int
  artist          Artist    @relation(fields: [artistId], references: [id])
  token           String    @default(uuid())
  tokenExpiration DateTime? @default(dbgenerated("(NOW() + '06:00:00'::interval)"))

  @@unique([email, artistId])
}

model UserTrackGroupPurchase {
  userId              Int
  user                User       @relation(fields: [userId], references: [id])
  trackGroupId        Int
  trackGroup          TrackGroup @relation(fields: [trackGroupId], references: [id])
  pricePaid           Int // in cents
  currencyPaid        String     @default("USD")
  datePurchased       DateTime   @default(now())
  stripeSessionKey    String?
  singleDownloadToken String?

  @@unique([userId, trackGroupId])
}

model UserTrackGroupWishlist {
  userId       Int
  user         User       @relation(fields: [userId], references: [id])
  trackGroupId Int
  trackGroup   TrackGroup @relation(fields: [trackGroupId], references: [id])
  createdAt    DateTime   @default(now())

  @@unique([userId, trackGroupId])
}

model TrackGroupDownloadCodes {
  id               String     @id @default(uuid()) @db.Uuid
  trackGroupId     Int
  trackGroup       TrackGroup @relation(fields: [trackGroupId], references: [id])
  downloadCode     String
  group            String
  redeemedByUserId Int?
  redeemedByUser   User?      @relation(fields: [redeemedByUserId], references: [id])
}

model TrackGroup {
  id                      Int                       @id @default(autoincrement())
  about                   String?
  artist                  Artist                    @relation(fields: [artistId], references: [id])
  artistId                Int
  title                   String?
  tracks                  Track[]
  cover                   TrackGroupCover?
  published               Boolean                   @default(false)
  type                    String?
  releaseDate             DateTime                  @default(now())
  adminEnabled            Boolean                   @default(true)
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  deletedAt               DateTime?
  minPrice                Int? // in cents
  currency                String?                   @default("USD")
  isPriceFixed            Boolean                   @default(false)
  userTrackGroupPurchases UserTrackGroupPurchase[]
  stripeProductKey        String?
  urlSlug                 String
  credits                 String?
  userTrackGroupWishlist  UserTrackGroupWishlist[]
  platformPercent         Int?                      @default(7)
  tags                    TrackGroupTag[]
  downloadCodes           TrackGroupDownloadCodes[]
  notifications           Notification[]

  @@unique([artistId, urlSlug])
}

model TrackGroupCover {
  id               String     @id @default(uuid()) @db.Uuid
  url              String[]
  trackGroup       TrackGroup @relation(fields: [trackGroupId], references: [id])
  trackGroupId     Int        @unique
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  deletedAt        DateTime?
  originalFilename String?
}

model Track {
  id           Int           @id @default(autoincrement())
  order        Int           @default(0)
  trackGroup   TrackGroup    @relation(fields: [trackGroupId], references: [id])
  trackGroupId Int
  title        String?
  audio        TrackAudio?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?
  isPreview    Boolean       @default(true)
  trackArtists TrackArtist[]
  metadata     Json?
  plays        TrackPlay[]
}

model TrackArtist {
  id         String  @id @default(uuid()) @db.Uuid
  trackId    Int
  track      Track   @relation(fields: [trackId], references: [id])
  artistName String?
  artistId   Int?
  artist     Artist? @relation(fields: [artistId], references: [id])
  role       String?
  isCoAuthor Boolean @default(false)
}

model TrackAudio {
  id               String       @id @default(uuid()) @db.Uuid
  url              String?
  track            Track?       @relation(fields: [trackId], references: [id])
  trackId          Int?         @unique
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  deletedAt        DateTime?
  originalFilename String?
  duration         Int? // In seconds
  hash             String?
  size             Int?
  fileExtension    String?
  uploadState      UploadState? @default(STARTED)
}

enum UploadState {
  SUCCESS
  ERROR
  STARTED
}

model TrackPlay {
  id        String   @id @default(uuid()) @db.Uuid
  trackId   Int
  track     Track    @relation(fields: [trackId], references: [id])
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id])
  ip        String?
  createdAt DateTime @default(now())
  owned     Boolean  @default(false)
}

model TrackGroupTag {
  trackGroupId Int
  trackGroup   TrackGroup @relation(fields: [trackGroupId], references: [id])
  tagId        Int
  tag          Tag        @relation(fields: [tagId], references: [id])

  @@unique([trackGroupId, tagId])
}

model Tag {
  id             Int             @id @default(autoincrement())
  tag            String          @unique
  trackGroupTags TrackGroupTag[]
}
